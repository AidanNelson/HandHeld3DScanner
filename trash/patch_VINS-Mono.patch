diff --git a/ar_demo/CMakeLists.txt b/ar_demo/CMakeLists.txt
deleted file mode 100644
index fc4e682..0000000
--- a/ar_demo/CMakeLists.txt
+++ /dev/null
@@ -1,43 +0,0 @@
-cmake_minimum_required(VERSION 2.8.3)
-project(ar_demo)
-
-set(CMAKE_BUILD_TYPE "Release")
-set(CMAKE_CXX_FLAGS "-std=c++11 -DEIGEN_DONT_PARALLELIZE")
-#-DEIGEN_USE_MKL_ALL")
-set(CMAKE_CXX_FLAGS_RELEASE "-O3 -Wall -g")
-
-find_package(catkin REQUIRED COMPONENTS
-  roscpp
-  rospy
-  std_msgs
-  image_transport
-  sensor_msgs
-  cv_bridge
-  message_filters
-  camera_model
-)
-find_package(OpenCV REQUIRED)
-
-catkin_package(
-
-)
-
-
-include_directories(
-  ${catkin_INCLUDE_DIRS}
-)
-
-set(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)
-find_package(Eigen3)
-include_directories(
-  ${catkin_INCLUDE_DIRS}
-  ${EIGEN3_INCLUDE_DIR}
-)
-
-add_executable(ar_demo_node src/ar_demo_node.cpp)
-
- target_link_libraries(ar_demo_node
-   ${catkin_LIBRARIES} ${OpenCV_LIBS}
- )
-
-
diff --git a/ar_demo/cmake/FindEigen.cmake b/ar_demo/cmake/FindEigen.cmake
deleted file mode 100644
index cdeb305..0000000
--- a/ar_demo/cmake/FindEigen.cmake
+++ /dev/null
@@ -1,172 +0,0 @@
-# Ceres Solver - A fast non-linear least squares minimizer
-# Copyright 2015 Google Inc. All rights reserved.
-# http://ceres-solver.org/
-#
-# Redistribution and use in source and binary forms, with or without
-# modification, are permitted provided that the following conditions are met:
-#
-# * Redistributions of source code must retain the above copyright notice,
-#   this list of conditions and the following disclaimer.
-# * Redistributions in binary form must reproduce the above copyright notice,
-#   this list of conditions and the following disclaimer in the documentation
-#   and/or other materials provided with the distribution.
-# * Neither the name of Google Inc. nor the names of its contributors may be
-#   used to endorse or promote products derived from this software without
-#   specific prior written permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-#
-# Author: alexs.mac@gmail.com (Alex Stewart)
-#
-
-# FindEigen.cmake - Find Eigen library, version >= 3.
-#
-# This module defines the following variables:
-#
-# EIGEN_FOUND: TRUE iff Eigen is found.
-# EIGEN_INCLUDE_DIRS: Include directories for Eigen.
-#
-# EIGEN_VERSION: Extracted from Eigen/src/Core/util/Macros.h
-# EIGEN_WORLD_VERSION: Equal to 3 if EIGEN_VERSION = 3.2.0
-# EIGEN_MAJOR_VERSION: Equal to 2 if EIGEN_VERSION = 3.2.0
-# EIGEN_MINOR_VERSION: Equal to 0 if EIGEN_VERSION = 3.2.0
-#
-# The following variables control the behaviour of this module:
-#
-# EIGEN_INCLUDE_DIR_HINTS: List of additional directories in which to
-#                          search for eigen includes, e.g: /timbuktu/eigen3.
-#
-# The following variables are also defined by this module, but in line with
-# CMake recommended FindPackage() module style should NOT be referenced directly
-# by callers (use the plural variables detailed above instead).  These variables
-# do however affect the behaviour of the module via FIND_[PATH/LIBRARY]() which
-# are NOT re-called (i.e. search for library is not repeated) if these variables
-# are set with valid values _in the CMake cache_. This means that if these
-# variables are set directly in the cache, either by the user in the CMake GUI,
-# or by the user passing -DVAR=VALUE directives to CMake when called (which
-# explicitly defines a cache variable), then they will be used verbatim,
-# bypassing the HINTS variables and other hard-coded search locations.
-#
-# EIGEN_INCLUDE_DIR: Include directory for CXSparse, not including the
-#                    include directory of any dependencies.
-
-# Called if we failed to find Eigen or any of it's required dependencies,
-# unsets all public (designed to be used externally) variables and reports
-# error message at priority depending upon [REQUIRED/QUIET/<NONE>] argument.
-macro(EIGEN_REPORT_NOT_FOUND REASON_MSG)
-  unset(EIGEN_FOUND)
-  unset(EIGEN_INCLUDE_DIRS)
-  # Make results of search visible in the CMake GUI if Eigen has not
-  # been found so that user does not have to toggle to advanced view.
-  mark_as_advanced(CLEAR EIGEN_INCLUDE_DIR)
-  # Note <package>_FIND_[REQUIRED/QUIETLY] variables defined by FindPackage()
-  # use the camelcase library name, not uppercase.
-  if (Eigen_FIND_QUIETLY)
-    message(STATUS "Failed to find Eigen - " ${REASON_MSG} ${ARGN})
-  elseif (Eigen_FIND_REQUIRED)
-    message(FATAL_ERROR "Failed to find Eigen - " ${REASON_MSG} ${ARGN})
-  else()
-    # Neither QUIETLY nor REQUIRED, use no priority which emits a message
-    # but continues configuration and allows generation.
-    message("-- Failed to find Eigen - " ${REASON_MSG} ${ARGN})
-  endif ()
-  return()
-endmacro(EIGEN_REPORT_NOT_FOUND)
-
-# Protect against any alternative find_package scripts for this library having
-# been called previously (in a client project) which set EIGEN_FOUND, but not
-# the other variables we require / set here which could cause the search logic
-# here to fail.
-unset(EIGEN_FOUND)
-
-# Search user-installed locations first, so that we prefer user installs
-# to system installs where both exist.
-list(APPEND EIGEN_CHECK_INCLUDE_DIRS
-  /usr/local/include
-  /usr/local/homebrew/include # Mac OS X
-  /opt/local/var/macports/software # Mac OS X.
-  /opt/local/include
-  /usr/include)
-# Additional suffixes to try appending to each search path.
-list(APPEND EIGEN_CHECK_PATH_SUFFIXES
-  eigen3 # Default root directory for Eigen.
-  Eigen/include/eigen3 # Windows (for C:/Program Files prefix) < 3.3
-  Eigen3/include/eigen3 ) # Windows (for C:/Program Files prefix) >= 3.3
-
-# Search supplied hint directories first if supplied.
-find_path(EIGEN_INCLUDE_DIR
-  NAMES Eigen/Core
-  PATHS ${EIGEN_INCLUDE_DIR_HINTS}
-  ${EIGEN_CHECK_INCLUDE_DIRS}
-  PATH_SUFFIXES ${EIGEN_CHECK_PATH_SUFFIXES})
-
-if (NOT EIGEN_INCLUDE_DIR OR
-    NOT EXISTS ${EIGEN_INCLUDE_DIR})
-  eigen_report_not_found(
-    "Could not find eigen3 include directory, set EIGEN_INCLUDE_DIR to "
-    "path to eigen3 include directory, e.g. /usr/local/include/eigen3.")
-endif (NOT EIGEN_INCLUDE_DIR OR
-       NOT EXISTS ${EIGEN_INCLUDE_DIR})
-
-# Mark internally as found, then verify. EIGEN_REPORT_NOT_FOUND() unsets
-# if called.
-set(EIGEN_FOUND TRUE)
-
-# Extract Eigen version from Eigen/src/Core/util/Macros.h
-if (EIGEN_INCLUDE_DIR)
-  set(EIGEN_VERSION_FILE ${EIGEN_INCLUDE_DIR}/Eigen/src/Core/util/Macros.h)
-  if (NOT EXISTS ${EIGEN_VERSION_FILE})
-    eigen_report_not_found(
-      "Could not find file: ${EIGEN_VERSION_FILE} "
-      "containing version information in Eigen install located at: "
-      "${EIGEN_INCLUDE_DIR}.")
-  else (NOT EXISTS ${EIGEN_VERSION_FILE})
-    file(READ ${EIGEN_VERSION_FILE} EIGEN_VERSION_FILE_CONTENTS)
-
-    string(REGEX MATCH "#define EIGEN_WORLD_VERSION [0-9]+"
-      EIGEN_WORLD_VERSION "${EIGEN_VERSION_FILE_CONTENTS}")
-    string(REGEX REPLACE "#define EIGEN_WORLD_VERSION ([0-9]+)" "\\1"
-      EIGEN_WORLD_VERSION "${EIGEN_WORLD_VERSION}")
-
-    string(REGEX MATCH "#define EIGEN_MAJOR_VERSION [0-9]+"
-      EIGEN_MAJOR_VERSION "${EIGEN_VERSION_FILE_CONTENTS}")
-    string(REGEX REPLACE "#define EIGEN_MAJOR_VERSION ([0-9]+)" "\\1"
-      EIGEN_MAJOR_VERSION "${EIGEN_MAJOR_VERSION}")
-
-    string(REGEX MATCH "#define EIGEN_MINOR_VERSION [0-9]+"
-      EIGEN_MINOR_VERSION "${EIGEN_VERSION_FILE_CONTENTS}")
-    string(REGEX REPLACE "#define EIGEN_MINOR_VERSION ([0-9]+)" "\\1"
-      EIGEN_MINOR_VERSION "${EIGEN_MINOR_VERSION}")
-
-    # This is on a single line s/t CMake does not interpret it as a list of
-    # elements and insert ';' separators which would result in 3.;2.;0 nonsense.
-    set(EIGEN_VERSION "${EIGEN_WORLD_VERSION}.${EIGEN_MAJOR_VERSION}.${EIGEN_MINOR_VERSION}")
-  endif (NOT EXISTS ${EIGEN_VERSION_FILE})
-endif (EIGEN_INCLUDE_DIR)
-
-# Set standard CMake FindPackage variables if found.
-if (EIGEN_FOUND)
-  set(EIGEN_INCLUDE_DIRS ${EIGEN_INCLUDE_DIR})
-endif (EIGEN_FOUND)
-
-# Handle REQUIRED / QUIET optional arguments and version.
-include(FindPackageHandleStandardArgs)
-find_package_handle_standard_args(Eigen
-  REQUIRED_VARS EIGEN_INCLUDE_DIRS
-  VERSION_VAR EIGEN_VERSION)
-
-# Only mark internal variables as advanced if we found Eigen, otherwise
-# leave it visible in the standard GUI for the user to set manually.
-if (EIGEN_FOUND)
-  mark_as_advanced(FORCE EIGEN_INCLUDE_DIR)
-endif (EIGEN_FOUND)
diff --git a/ar_demo/launch/3dm_bag.launch b/ar_demo/launch/3dm_bag.launch
deleted file mode 100644
index 8e1b300..0000000
--- a/ar_demo/launch/3dm_bag.launch
+++ /dev/null
@@ -1,11 +0,0 @@
-<launch>
-	<include file="$(find vins_estimator)/launch/3dm.launch"/>
-
-    <node pkg="ar_demo" type="ar_demo_node" name="ar_demo_node" output="screen">
-        <remap from="~image_raw" to="/mv_25001498/image_raw"/>
-        <remap from="~camera_pose" to="/vins_estimator/camera_pose"/>
-        <remap from="~pointcloud" to="/vins_estimator/point_cloud"/>
-        <param name="calib_file" type="string" value="$(find feature_tracker)/../config/3dm/3dm_config.yaml"/>
-        <param name="use_undistored_img" type="bool" value="false"/>
-    </node>
-</launch>
\ No newline at end of file
diff --git a/ar_demo/launch/ar_rviz.launch b/ar_demo/launch/ar_rviz.launch
deleted file mode 100644
index 105063b..0000000
--- a/ar_demo/launch/ar_rviz.launch
+++ /dev/null
@@ -1,3 +0,0 @@
-<launch>
-    <node name="rvizvisualisation" pkg="rviz" type="rviz" output="log" args="-d $(find ar_demo)/../config/AR_demo.rviz" />
-</launch>
\ No newline at end of file
diff --git a/ar_demo/launch/realsense_ar.launch b/ar_demo/launch/realsense_ar.launch
deleted file mode 100755
index 68c63ee..0000000
--- a/ar_demo/launch/realsense_ar.launch
+++ /dev/null
@@ -1,11 +0,0 @@
-<launch>
-	<include file="$(find vins_estimator)/launch/realsense_fisheye.launch"/>
-
-    <node pkg="ar_demo" type="ar_demo_node" name="ar_demo_node" output="screen">
-        <remap from="~image_raw" to="/camera/fisheye/image_raw"/>
-        <remap from="~camera_pose" to="/vins_estimator/camera_pose"/>
-        <remap from="~pointcloud" to="/vins_estimator/point_cloud"/>
-        <param name="calib_file" type="string" value="$(find feature_tracker)/../config/realsense/realsense_fisheye_config.yaml"/>
-        <param name="use_undistored_img" type="bool" value="false"/>
-    </node>
-</launch>
diff --git a/ar_demo/package.xml b/ar_demo/package.xml
deleted file mode 100644
index 7427024..0000000
--- a/ar_demo/package.xml
+++ /dev/null
@@ -1,58 +0,0 @@
-<?xml version="1.0"?>
-<package>
-  <name>ar_demo</name>
-  <version>0.0.0</version>
-  <description>The ar_demo package</description>
-
-  <!-- One maintainer tag required, multiple allowed, one person per tag --> 
-  <!-- Example:  -->
-  <!-- <maintainer email="jane.doe@example.com">Jane Doe</maintainer> -->
-  <maintainer email="qintonguav@gmail.com">tony-ws</maintainer>
-
-
-  <!-- One license tag required, multiple allowed, one license per tag -->
-  <!-- Commonly used license strings: -->
-  <!--   BSD, MIT, Boost Software License, GPLv2, GPLv3, LGPLv2.1, LGPLv3 -->
-  <license>TODO</license>
-
-
-  <!-- Url tags are optional, but mutiple are allowed, one per tag -->
-  <!-- Optional attribute type can be: website, bugtracker, or repository -->
-  <!-- Example: -->
-  <!-- <url type="website">http://wiki.ros.org/AR_demo</url> -->
-
-
-  <!-- Author tags are optional, mutiple are allowed, one per tag -->
-  <!-- Authors do not have to be maintianers, but could be -->
-  <!-- Example: -->
-  <!-- <author email="jane.doe@example.com">Jane Doe</author> -->
-
-
-  <!-- The *_depend tags are used to specify dependencies -->
-  <!-- Dependencies can be catkin packages or system dependencies -->
-  <!-- Examples: -->
-  <!-- Use build_depend for packages you need at compile time: -->
-  <!--   <build_depend>message_generation</build_depend> -->
-  <!-- Use buildtool_depend for build tool packages: -->
-  <!--   <buildtool_depend>catkin</buildtool_depend> -->
-  <!-- Use run_depend for packages you need at runtime: -->
-  <!--   <run_depend>message_runtime</run_depend> -->
-  <!-- Use test_depend for packages you need only for testing: -->
-  <!--   <test_depend>gtest</test_depend> -->
-  <buildtool_depend>catkin</buildtool_depend>
-  <build_depend>roscpp</build_depend>
-  <build_depend>rospy</build_depend>
-  <build_depend>std_msgs</build_depend>
-  <build_depend>camera_model</build_depend>
-  <run_depend>roscpp</run_depend>
-  <run_depend>rospy</run_depend>
-  <run_depend>std_msgs</run_depend>
-  <run_depend>camera_model</run_depend>
-
-
-  <!-- The export tag contains other, unspecified, tags -->
-  <export>
-    <!-- Other tools can request additional information be placed here -->
-
-  </export>
-</package>
\ No newline at end of file
diff --git a/ar_demo/src/ar_demo_node.cpp b/ar_demo/src/ar_demo_node.cpp
deleted file mode 100644
index 95c3a22..0000000
--- a/ar_demo/src/ar_demo_node.cpp
+++ /dev/null
@@ -1,557 +0,0 @@
-#include <ros/ros.h>
-#include <std_msgs/ColorRGBA.h>
-#include <visualization_msgs/Marker.h>
-#include <visualization_msgs/MarkerArray.h>
-#include <nav_msgs/Odometry.h>
-#include <geometry_msgs/PoseStamped.h>
-#include <sensor_msgs/Image.h>
-#include <sensor_msgs/image_encodings.h>
-#include <sensor_msgs/PointCloud.h>
-#include <cv_bridge/cv_bridge.h>
-#include <image_transport/image_transport.h>
-#include <cmath>
-#include <opencv2/opencv.hpp>
-#include <opencv2/highgui/highgui.hpp>
-#include <eigen3/Eigen/Dense>
-#include <eigen3/Eigen/Geometry>
-#include <vector>
-#include <message_filters/subscriber.h>
-#include <message_filters/time_synchronizer.h>
-#include <message_filters/synchronizer.h>
-#include <message_filters/sync_policies/approximate_time.h>
-#include "camodocal/camera_models/CameraFactory.h"
-#include "camodocal/camera_models/CataCamera.h"
-#include "camodocal/camera_models/PinholeCamera.h"
-#include <queue>
-#include <cmath>
-#include <algorithm> 
-#include <sensor_msgs/Image.h>
-#include <sensor_msgs/image_encodings.h>
-
-using namespace std;
-using namespace Eigen;
-using namespace sensor_msgs;
-using namespace message_filters;
-using namespace camodocal;
-
-int ROW;
-int COL;
-double FOCAL_LENGTH;
-const int axis_num = 0;
-const int cube_num = 1;
-const double box_length = 0.8;
-bool USE_UNDISTORED_IMG;
-bool pose_init = false;
-int img_cnt = 0;
-
-ros::Publisher object_pub;
-image_transport::Publisher pub_ARimage;
-Vector3d Axis[6];
-Vector3d Cube_center[3];
-vector<Vector3d> Cube_corner[3];
-vector<Vector3d> output_Axis[6];
-vector<Vector3d> output_Cube[3];
-vector<double> output_corner_dis[3];
-double Cube_center_depth[3];
-queue<ImageConstPtr> img_buf;
-camodocal::CameraPtr m_camera;
-bool look_ground = 0;
-std_msgs::ColorRGBA line_color_r;
-std_msgs::ColorRGBA line_color_g;
-std_msgs::ColorRGBA line_color_b;
-
-void axis_generate(visualization_msgs::Marker &line_list, Vector3d &origin, int id)
-{
-
-    line_list.id = id;
-    line_list.header.frame_id = "world";
-    line_list.header.stamp = ros::Time::now();
-    line_list.action = visualization_msgs::Marker::ADD;
-    line_list.type = visualization_msgs::Marker::LINE_LIST;
-    line_list.scale.x = 0.1;
-    line_list.color.a = 1.0;
-    line_list.lifetime = ros::Duration();
-    
-    line_list.pose.orientation.w = 1.0;
-    line_list.color.b = 1.0;
-    geometry_msgs::Point p;
-    p.x = origin.x();
-    p.y = origin.y();
-    p.z = origin.z();
-    line_list.points.push_back(p);
-    line_list.colors.push_back(line_color_r);
-    p.x += 1.0;
-    line_list.points.push_back(p);
-    line_list.colors.push_back(line_color_r);
-    p.x -= 1.0;
-    line_list.points.push_back(p);
-    line_list.colors.push_back(line_color_g);
-    p.y += 1.0;
-    line_list.points.push_back(p);
-    line_list.colors.push_back(line_color_g);
-    p.y -= 1.0;
-    line_list.points.push_back(p);
-    line_list.colors.push_back(line_color_b);
-    p.z += 1.0;
-    line_list.points.push_back(p);
-    line_list.colors.push_back(line_color_b);
-}
-
-void cube_generate(visualization_msgs::Marker &marker, Vector3d &origin, int id)
-{
-
-    //uint32_t shape = visualization_msgs::Marker::CUBE;
-    marker.header.frame_id = "world";
-    marker.header.stamp = ros::Time::now();
-    marker.ns = "basic_shapes";
-    marker.id = 0;
-    //marker.type = shape;
-    marker.action = visualization_msgs::Marker::ADD;
-    marker.type = visualization_msgs::Marker::CUBE_LIST;
-    /*
-    marker.pose.position.x = origin.x();
-    marker.pose.position.y = origin.y();
-    marker.pose.position.z = origin.z();
-    marker.pose.orientation.x = 0.0;
-    marker.pose.orientation.y = 0.0;
-    marker.pose.orientation.z = 0.0;
-    marker.pose.orientation.w = 1.0;
-    */
-    marker.scale.x = box_length;
-    marker.scale.y = box_length;
-    marker.scale.z = box_length;
-
-    marker.color.r = 0.0f;
-    marker.color.g = 1.0f;
-    marker.color.b = 0.0f;
-    marker.color.a = 1.0;
-
-    marker.lifetime = ros::Duration();  
-    geometry_msgs::Point p;
-    p.x = origin.x();
-    p.y = origin.y();
-    p.z = origin.z();
-    marker.points.push_back(p);
-    marker.colors.push_back(line_color_r);
-    Cube_corner[id].clear();
-    Cube_corner[id].push_back(Vector3d(origin.x() - box_length / 2, origin.y() - box_length / 2, origin.z() - box_length / 2));
-    Cube_corner[id].push_back(Vector3d(origin.x() + box_length / 2, origin.y() - box_length / 2, origin.z() - box_length / 2));
-    Cube_corner[id].push_back(Vector3d(origin.x() - box_length / 2, origin.y() + box_length / 2, origin.z() - box_length / 2));
-    Cube_corner[id].push_back(Vector3d(origin.x() + box_length / 2, origin.y() + box_length / 2, origin.z() - box_length / 2));
-    Cube_corner[id].push_back(Vector3d(origin.x() - box_length / 2, origin.y() - box_length / 2, origin.z() + box_length / 2));
-    Cube_corner[id].push_back(Vector3d(origin.x() + box_length / 2, origin.y() - box_length / 2, origin.z() + box_length / 2));
-    Cube_corner[id].push_back(Vector3d(origin.x() - box_length / 2, origin.y() + box_length / 2, origin.z() + box_length / 2));
-    Cube_corner[id].push_back(Vector3d(origin.x() + box_length / 2, origin.y() + box_length / 2, origin.z() + box_length / 2));
-}
-
-void add_object()
-{
-    visualization_msgs::MarkerArray markerArray_msg;
-
-    visualization_msgs::Marker line_list;
-    visualization_msgs::Marker cube_list;
-
-    for (int i = 0; i < axis_num; i++)
-    {
-        axis_generate(line_list, Axis[i], i);
-        markerArray_msg.markers.push_back(line_list);
-    }
-
-    for (int i = 0; i <cube_num; i++)
-    {
-        cube_generate(cube_list, Cube_center[i], i);
-    }
-    //cube_generate(cube_list, Cube_center[2], 2);
-    markerArray_msg.markers.push_back(cube_list);
-
-    object_pub.publish(markerArray_msg);
-}
-
-void project_object(Vector3d camera_p, Quaterniond camera_q)
-{
-    for (int i = 0; i < axis_num; i++)
-    {
-        output_Axis[i].clear();
-        Vector3d local_point;
-        Vector2d local_uv;
-        local_point = camera_q.inverse() * (Axis[i] - camera_p);
-        m_camera->spaceToPlane(local_point, local_uv);
-
-        if (local_point.z() > 0)
-            //&& 0 <= local_uv.x() && local_uv.x() <= COL - 1 && 0 <= local_uv.y() && local_uv.y() <= ROW -1)
-        {
-            output_Axis[i].push_back(Vector3d(local_uv.x(), local_uv.y(), 1));
-
-            local_point = camera_q.inverse() * (Axis[i] + Vector3d(1, 0, 0) - camera_p);
-            m_camera->spaceToPlane(local_point, local_uv);
-            output_Axis[i].push_back(Vector3d(local_uv.x(), local_uv.y(), 1));
-
-            local_point = camera_q.inverse() * (Axis[i] + Vector3d(0, 1, 0) - camera_p);
-            m_camera->spaceToPlane(local_point, local_uv);
-            output_Axis[i].push_back(Vector3d(local_uv.x(), local_uv.y(), 1));
-
-            local_point = camera_q.inverse() * (Axis[i] + Vector3d(0, 0, 1) - camera_p);
-            m_camera->spaceToPlane(local_point, local_uv);
-            output_Axis[i].push_back(Vector3d(local_uv.x(), local_uv.y(), 1));
-
-        }
-    } 
-
-    for (int i = 0; i < cube_num; i++)
-    {
-        output_Cube[i].clear();
-        output_corner_dis[i].clear();
-        Vector3d local_point;
-        Vector2d local_uv;
-        local_point = camera_q.inverse() * (Cube_center[i] - camera_p);
-        if (USE_UNDISTORED_IMG)
-        {
-            local_uv.x() = local_point(0) / local_point(2) * FOCAL_LENGTH + COL / 2;
-            local_uv.y() = local_point(1) / local_point(2) * FOCAL_LENGTH + ROW / 2;
-        }
-        else
-            m_camera->spaceToPlane(local_point, local_uv);
-        if (local_point.z() > box_length / 2)
-           //&& 0 <= local_uv.x() && local_uv.x() <= COL - 1 && 0 <= local_uv.y() && local_uv.y() <= ROW -1)
-        {
-            Cube_center_depth[i] = local_point.z();
-            for (int j = 0; j < 8; j++)
-            {
-                local_point = camera_q.inverse() * (Cube_corner[i][j] - camera_p);
-                output_corner_dis[i].push_back(local_point.norm());
-                if (USE_UNDISTORED_IMG)
-                {
-                    //ROS_INFO("directly project!");
-                    local_uv.x() = local_point(0) / local_point(2) * FOCAL_LENGTH + COL / 2;
-                    local_uv.y() = local_point(1) / local_point(2) * FOCAL_LENGTH + ROW / 2;
-                }
-                else
-                {
-                    //ROS_INFO("camera model project!");
-                    m_camera->spaceToPlane(local_point, local_uv);
-                    local_uv.x() = std::min(std::max(-5000.0, local_uv.x()),5000.0);
-                    local_uv.y() = std::min(std::max(-5000.0, local_uv.y()),5000.0);
-                }
-                output_Cube[i].push_back(Vector3d(local_uv.x(), local_uv.y(), 1));
-            }
-        }
-        else
-        {
-            Cube_center_depth[i] = -1;
-        }
-
-    }   
-}
-
-void draw_object(cv::Mat &AR_image)
-{
-    for (int i = 0; i < axis_num; i++)
-    {
-        if(output_Axis[i].empty())
-            continue;
-        cv::Point2d origin(output_Axis[i][0].x(), output_Axis[i][0].y());
-        cv::Point2d axis_x(output_Axis[i][1].x(), output_Axis[i][1].y());
-        cv::Point2d axis_y(output_Axis[i][2].x(), output_Axis[i][2].y());
-        cv::Point2d axis_z(output_Axis[i][3].x(), output_Axis[i][3].y());
-        cv::line(AR_image, origin, axis_x, cv::Scalar(0, 0, 255), 2, 8, 0);
-        cv::line(AR_image, origin, axis_y, cv::Scalar(0, 255, 0), 2, 8, 0);
-        cv::line(AR_image, origin, axis_z, cv::Scalar(255, 0, 0), 2, 8, 0);
-    }
-
-    //depth sort  big---->small
-    int index[cube_num];
-    for (int i = 0; i < cube_num; i++)
-    {
-        index[i] = i;
-        //cout << "i " << i << " init depth" << Cube_center_depth[i] << endl;
-    }
-    for (int i = 0; i < cube_num; i++)
-        for (int j = 0; j < cube_num - i - 1; j++)
-        {
-            if (Cube_center_depth[j] < Cube_center_depth[j + 1])
-            {
-                double tmp = Cube_center_depth[j];
-                Cube_center_depth[j] = Cube_center_depth[j + 1];
-                Cube_center_depth[j + 1] = tmp;
-                int tmp_index = index[j];
-                index[j] = index[j + 1];
-                index[j + 1] = tmp_index;
-            }
-        }
-
-    for (int k = 0; k < cube_num; k++)
-    {
-        int i = index[k];
-        //cout << "draw " << i << "depth " << Cube_center_depth[i] << endl;
-        if (output_Cube[i].empty())
-            continue;
-        //draw color
-        cv::Point* p = new cv::Point[8];
-        p[0] = cv::Point(output_Cube[i][0].x(), output_Cube[i][0].y());
-        p[1] = cv::Point(output_Cube[i][1].x(), output_Cube[i][1].y());
-        p[2] = cv::Point(output_Cube[i][2].x(), output_Cube[i][2].y());
-        p[3] = cv::Point(output_Cube[i][3].x(), output_Cube[i][3].y());
-        p[4] = cv::Point(output_Cube[i][4].x(), output_Cube[i][4].y());
-        p[5] = cv::Point(output_Cube[i][5].x(), output_Cube[i][5].y());
-        p[6] = cv::Point(output_Cube[i][6].x(), output_Cube[i][6].y());
-        p[7] = cv::Point(output_Cube[i][7].x(), output_Cube[i][7].y());
-        
-        int npts[1] = {4};
-        float min_depth = 100000;
-        int min_index = 5;
-        for(int j= 0; j < (int)output_corner_dis[i].size(); j++)
-        {
-            if(output_corner_dis[i][j] < min_depth)
-            {
-                min_depth = output_corner_dis[i][j];
-                min_index = j;
-            }
-        }
-        
-        cv::Point plain[1][4];
-        const cv::Point* ppt[1] = {plain[0]};
-        //first draw large depth plane
-        int point_group[8][12] = {{0,1,5,4, 0,4,6,2, 0,1,3,2},
-            {0,1,5,4, 1,5,7,3, 0,1,3,2},
-            {2,3,7,6, 0,4,6,2, 0,1,3,2},
-            {2,3,7,6, 1,5,7,3, 0,1,3,2},
-            {0,1,5,4, 0,4,6,2, 4,5,7,6},
-            {0,1,5,4, 1,5,7,3, 4,5,7,6},
-            {2,3,7,6, 0,4,6,2, 4,5,7,6},
-            {2,3,7,6, 1,5,7,3, 4,5,7,6}};
-        
-        plain[0][0] = p[point_group[min_index][4]];
-        plain[0][1] = p[point_group[min_index][5]];
-        plain[0][2] = p[point_group[min_index][6]];
-        plain[0][3] = p[point_group[min_index][7]];
-        cv::fillPoly(AR_image, ppt, npts, 1, cv::Scalar(0, 200, 0));
-        
-        plain[0][0] = p[point_group[min_index][0]];
-        plain[0][1] = p[point_group[min_index][1]];
-        plain[0][2] = p[point_group[min_index][2]];
-        plain[0][3] = p[point_group[min_index][3]];
-        cv::fillPoly(AR_image, ppt, npts, 1, cv::Scalar(200, 0, 0));
-        
-        if(output_corner_dis[i][point_group[min_index][2]] + output_corner_dis[i][point_group[min_index][3]] >
-           output_corner_dis[i][point_group[min_index][5]] + output_corner_dis[i][point_group[min_index][6]])
-        {
-            plain[0][0] = p[point_group[min_index][4]];
-            plain[0][1] = p[point_group[min_index][5]];
-            plain[0][2] = p[point_group[min_index][6]];
-            plain[0][3] = p[point_group[min_index][7]];
-            cv::fillPoly(AR_image, ppt, npts, 1, cv::Scalar(0, 200, 0));
-
-        }
-        plain[0][0] = p[point_group[min_index][8]];
-        plain[0][1] = p[point_group[min_index][9]];
-        plain[0][2] = p[point_group[min_index][10]];
-        plain[0][3] = p[point_group[min_index][11]];
-        cv::fillPoly(AR_image, ppt, npts, 1, cv::Scalar(0, 0, 200));
-        delete p;
-    }
-}
-
-void callback(const ImageConstPtr& img_msg, const nav_msgs::Odometry::ConstPtr pose_msg)
-{
-    //throw the first few unstable pose
-    if(img_cnt < 50)
-    {
-        img_cnt ++;
-        return;
-    }
-   //ROS_INFO("sync callback!");
-   Vector3d camera_p(pose_msg->pose.pose.position.x,
-                     pose_msg->pose.pose.position.y,
-                     pose_msg->pose.pose.position.z);
-   Quaterniond camera_q(pose_msg->pose.pose.orientation.w,
-                        pose_msg->pose.pose.orientation.x,
-                        pose_msg->pose.pose.orientation.y,
-                        pose_msg->pose.pose.orientation.z);
-
-   //test plane
-   Vector3d cam_z(0, 0, -1);
-   Vector3d w_cam_z = camera_q * cam_z;
-   //cout << "angle " << acos(w_cam_z.dot(Vector3d(0, 0, 1))) * 180.0 / M_PI << endl;
-   if (acos(w_cam_z.dot(Vector3d(0, 0, 1))) * 180.0 / M_PI < 90)
-   {
-        //ROS_WARN(" look down");
-        look_ground = 1;
-   }
-   else
-        look_ground = 0;
-
-   project_object(camera_p, camera_q);
-
-   cv_bridge::CvImageConstPtr ptr;
-   if (img_msg->encoding == "8UC1")
-   {
-       sensor_msgs::Image img;
-       img.header = img_msg->header;
-       img.height = img_msg->height;
-       img.width = img_msg->width;
-       img.is_bigendian = img_msg->is_bigendian;
-       img.step = img_msg->step;
-       img.data = img_msg->data;
-       img.encoding = "mono8";
-       ptr = cv_bridge::toCvCopy(img, sensor_msgs::image_encodings::MONO8);
-   }
-   else
-       ptr = cv_bridge::toCvCopy(img_msg, sensor_msgs::image_encodings::MONO8);
-
-   //cv_bridge::CvImagePtr bridge_ptr = cv_bridge::toCvCopy(ptr, sensor_msgs::image_encodings::MONO8);
-   cv::Mat AR_image;
-   AR_image = ptr->image.clone();
-   cv::cvtColor(AR_image, AR_image, cv::COLOR_GRAY2RGB);
-   draw_object(AR_image);
-
-   sensor_msgs::ImagePtr AR_msg = cv_bridge::CvImage(img_msg->header, "bgr8", AR_image).toImageMsg();
-   pub_ARimage.publish(AR_msg);
-
-}
-void point_callback(const sensor_msgs::PointCloudConstPtr &point_msg)
-{
-    if (!look_ground)
-        return;
-    int height_range[30];
-    double height_sum[30];
-    for (int i = 0; i < 30; i++)
-    {
-        height_range[i] = 0;
-        height_sum[i] = 0;
-    }
-    for (unsigned int i = 0; i < point_msg->points.size(); i++)
-    {
-        //double x = point_msg->points[i].x;
-        //double y = point_msg->points[i].y;
-        double z = point_msg->points[i].z;
-        int index = (z + 2.0) / 0.1;
-        if (0 <= index && index < 30)
-        {
-            height_range[index]++;
-            height_sum[index] += z;
-        }
-        //cout << "point " << " z " << z << endl;
-    }
-    int max_num = 0;
-    int max_index = -1;
-    for (int i = 1; i < 29; i++)
-    {
-        if (max_num < height_range[i])
-        {
-            max_num = height_range[i];
-            max_index = i;
-        }
-    }
-    if (max_index == -1)
-        return;
-    int tmp_num = height_range[max_index - 1] + height_range[max_index] + height_range[max_index + 1];
-    double new_height = (height_sum[max_index - 1] + height_sum[max_index] + height_sum[max_index + 1]) / tmp_num;
-    //ROS_WARN("detect ground plain, height %f", new_height);
-    if (tmp_num < (int)point_msg->points.size() / 2)
-    {
-        //ROS_INFO("points not enough");
-        return;
-    }
-    //update height
-    for (int i = 0; i < cube_num; i++)
-    {
-        Cube_center[i].z() = new_height + box_length / 2.0;
-    }
-    add_object();
-
-}
-void img_callback(const ImageConstPtr& img_msg)
-{
-    if(pose_init)
-    {
-        img_buf.push(img_msg);
-    }
-    else
-        return;
-}
-void pose_callback(const nav_msgs::Odometry::ConstPtr &pose_msg)
-{
-    if(!pose_init)
-    {
-        pose_init = true;
-        return;
-    }
-
-    if (img_buf.empty())
-    {
-        //ROS_WARN("image coming late");
-        return;
-    }
-
-    while (img_buf.front()->header.stamp < pose_msg->header.stamp && !img_buf.empty())
-    {
-        img_buf.pop();
-    }
-
-    if (!img_buf.empty())
-    {
-        callback(img_buf.front(), pose_msg);
-        img_buf.pop();
-    }
-    //else
-    //    ROS_WARN("image coming late");
-}
-int main( int argc, char** argv )
-{
-    ros::init(argc, argv, "points_and_lines");
-    ros::NodeHandle n("~");
-    object_pub = n.advertise<visualization_msgs::MarkerArray>("AR_object", 10);
-    n.getParam("use_undistored_img", USE_UNDISTORED_IMG);
-    ros::Subscriber sub_img;
-    if (USE_UNDISTORED_IMG)
-    {
-        // the same as image crop
-        ROW = 600;
-        COL = 480;
-        FOCAL_LENGTH = 320.0;
-        sub_img = n.subscribe("image_undistored", 100, img_callback);
-    }
-    else
-    {
-        ROW = 752;
-        COL = 480;
-        FOCAL_LENGTH = 460.0;
-        sub_img = n.subscribe("image_raw", 100, img_callback);
-    }
-
-    Axis[0] = Vector3d(0, 1.5, -1.2);
-    Axis[1]= Vector3d(-10, 5, 0);
-    Axis[2] = Vector3d(3, 3, 3);
-    Axis[3] = Vector3d(-2, 2, 0);
-    Axis[4]= Vector3d(5, 10, -5);
-    Axis[5] = Vector3d(0, 10, -1);
-
-    Cube_center[0] = Vector3d(0, 1.5, -1.2 + box_length / 2.0);
-    //Cube_center[0] = Vector3d(0, 3, -1.2 + box_length / 2.0);
-    Cube_center[1] = Vector3d(4, -2, -1.2 + box_length / 2.0);
-    Cube_center[2] = Vector3d(0, -2, -1.2 + box_length / 2.0);
-
-    ros::Subscriber pose_img = n.subscribe("camera_pose", 100, pose_callback);
-    ros::Subscriber sub_point = n.subscribe("pointcloud", 2000, point_callback);
-    image_transport::ImageTransport it(n);
-    pub_ARimage = it.advertise("AR_image", 1000);
-
-    line_color_r.r = 1.0;
-    line_color_r.a = 1.0;
-    line_color_g.g = 1.0;
-    line_color_g.a = 1.0;
-    line_color_b.b = 1.0;
-    line_color_b.a = 1.0;
-
-    string calib_file;
-    n.getParam("calib_file", calib_file);
-    ROS_INFO("reading paramerter of camera %s", calib_file.c_str());
-    m_camera = CameraFactory::instance()->generateCameraFromYamlFile(calib_file);
-
-    ros::Rate r(100);
-    ros::Duration(1).sleep();
-    add_object();
-    add_object();
-    ros::spin();
-}
-
diff --git a/feature_tracker/CMakeLists.txt b/feature_tracker/CMakeLists.txt
index bc3fb44..df036ed 100644
--- a/feature_tracker/CMakeLists.txt
+++ b/feature_tracker/CMakeLists.txt
@@ -26,6 +26,7 @@ find_package(Eigen3)
 include_directories(
   ${catkin_INCLUDE_DIRS}
   ${EIGEN3_INCLUDE_DIR}
+  ../camera_model/include
 )
 
 add_executable(feature_tracker
